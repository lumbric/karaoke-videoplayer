<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Karaoke ab Hof üé§</title>
  <script src="static/chart.js"></script>
  <style>
    @font-face {
      font-family: 'RocknRoll One';
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src: url(static/RocknRollOne.ttf) format('truetype');
    }

    body {
      margin: 0;
      font-family: 'RocknRoll One', sans-serif;
      background: #332e5d;
      min-height: 100vh;
      color: white;
      overflow-x: hidden;
      line-height: 1.4;
      position: relative;
    }

    h1 {
      text-align: center;
      margin: 1em 0 0.5em 0;
      font-size: 4em;
      color: #cd6391;
      font-weight: bolder;
      position: relative;
      z-index: 1;
      letter-spacing: 2px;
    }

    /*
    h1::before,
    h1::after {
      content: '‚ú®';
      font-size: 0.6em;
      color: #ff1493;
      margin: 0 20px;
      text-shadow: 2px 2px 4px rgba(46, 37, 92, 0.3);
    }
    */

    #search {
      margin: 1.5em auto 2em auto;
      display: block;
      padding: 1em 1.5em;
      width: min(600px, 80%);
      font-size: 1.2em;
      font-family: 'RocknRoll One', sans-serif;
      border: 0px;
      border-radius: 25px;
      background: white;
      color: #4E4E4E;
      text-align: center;
      transition: all 0.1s ease;
      outline: none;
      position: relative;
      z-index: 1;
    }
    #search:focus {
      transform: scale(1.06);
    }
    #search::placeholder {
      text-align: center;
      color: #a791b5;
    }
    .search-info {
      display: none;
    }

    .video-grid {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 25px;
      padding: 20px 40px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .card {
      background: #cd6391;
      border: 0px;
      border-radius: 15px;
      padding: 15px;
      width: 250px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      z-index: 1;
    }


    .card:hover {
      transform: scale(1.08) translateY(0px);
    }

    .card img {
      width: 100%;
      height: 250px;
      object-fit: cover;
      border-radius: 15px;
      border: 0px;
    }

    .title {
      margin-top: 1em;
      font-weight: bold;
      font-size: 1.1em;
      text-align: center;
      color: white;
    }

    #playerContainer {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: #000;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      cursor: none;
    }

    #playerContainer.show-cursor {
      cursor: default;
    }

    video {
        width: 100vw;
        height: 100vh;
        object-fit: contain;
        background: #000;
    }
    
    /* Hide video controls to prevent fast-forwarding */
    video::-webkit-media-controls-timeline {
      display: none !important;
    }
    
    video::-moz-range-progress {
      display: none !important;
    }
    
    video::-moz-range-track {
      display: none !important;
    }
    
    /* Hide picture-in-picture button */
    video::-webkit-media-controls-picture-in-picture-button {
      display: none !important;
    }
    
    video::-webkit-media-controls-fullscreen-button {
      display: none !important;
    }
    
    /* Alternative: Completely hide all controls and add custom ones */
    .video-overlay {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 1002;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .video-overlay.visible {
      opacity: 1;
    }
    
    .video-control-btn {
      background: rgba(68, 70, 127, 0.9);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'RocknRoll One', sans-serif;
      font-size: 0.9em;
      backdrop-filter: blur(10px);

      /* not the nicest solution, but the button should have a fixed size independent of its content */
      height: 49px;
      width: 120px;
    }
    
    .video-control-btn:hover {
      background: rgba(205, 99, 145, 0.9);
    }

    button {
      background: #44467f;
      color: white;
      font-family: 'RocknRoll One', sans-serif;
      padding: 15px 20px;
      border: 0px;
      color: white;
      border-radius: 15px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.3s ease;
    }

    button:hover {
        background: #cd6391;
    }

    #closeBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 12px 16px;
      font-size: 1.2em;
      display: none;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #closeBtn.visible {
      opacity: 1;
    }

    #statsButton {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10;
    }

    #statsPage {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      z-index: 2000;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
    }

    .stat-card {
      background: linear-gradient(145deg, #cd6391 0%, #b8578a 100%);
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(205, 99, 145, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .stat-card h3 {
      margin: 0 0 10px 0;
      font-size: 1em;
      color: white;
      opacity: 0.9;
    }

    .stat-number {
      font-size: 1.8em;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .chart-container {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }

    .chart-container h3 {
      margin: 0 0 15px 0;
      color: #cd6391;
      font-size: 1.2em;
      text-align: center;
    }

    .favorite-item, .activity-item {
      background: rgba(205, 99, 145, 0.2);
      margin: 8px 0;
      padding: 12px;
      border-radius: 8px;
      border-left: 4px solid #cd6391;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .favorite-item .song-title, .activity-item .song-title {
      font-weight: bold;
      color: white;
    }

    .favorite-item .completion, .activity-item .time {
      color: #cd6391;
      font-size: 0.9em;
    }

    #closeStats {
      position: absolute;
      top: 10px;
      right: 10px;
    }

    /* Static cosmic/party decorative elements (no animations) */
    .cosmic-decoration {
      position: fixed;
      font-size: 2em;
      opacity: 0.15;
      z-index: 0;
      pointer-events: none;
      color: #ff69b4;
    }

    .cosmic-decoration:nth-child(1) { top: 10%; left: 5%; }
    .cosmic-decoration:nth-child(2) { top: 20%; right: 8%; }
    .cosmic-decoration:nth-child(3) { bottom: 15%; left: 10%; }
    .cosmic-decoration:nth-child(4) { bottom: 25%; right: 15%; }

    .header-box {
        position: relative;
        width:1000px;
        margin:auto;
    }

    .singing-chicken {
        position: fixed;
        left: 20px;
        top: 10px;
        width: 400px;
    }

    /* Responsive Design */

    @media (max-width: 2000px) {
        .singing-chicken {
          position: absolute;
          left: -90px;
          top:-10px;
          width: 220px;
        }
    }

    @media (max-width: 1275px) {
        .singing-chicken {
            display: none;
        }
    }

    @media (max-width: 768px) {
      .video-grid {
        padding: 20px 20px;
        gap: 20px;
        justify-content: center;
      }
      .card {
        width: 200px;
      }
      .card img {
        height: 200px;
      }
      h1 {
        font-size: 2.2em;
      }
      h1::before,
      h1::after {
        font-size: 0.5em;
        margin: 0 15px;
      }
      #search {
        width: 90%;
        font-size: 1.1em;
        padding: 0.8em 1.2em;
      }
      .cosmic-decoration {
        display: none;
      }
      
      /* Statistics responsive */
      #statsPage div[style*="grid-template-columns: 1fr 1fr"] {
        display: block !important;
      }
      .chart-container {
        margin-bottom: 20px;
      }
    }

    @media (max-width: 480px) {
      .video-grid {
        padding: 15px 15px;
        gap: 15px;
      }
      .card {
        width: 160px;
      }
      .card img {
        height: 160px;
      }
      h1 {
        font-size: 1.8em;
      }
      h1::before,
      h1::after {
        font-size: 0.4em;
        margin: 0 10px;
      }
      #search {
        font-size: 1em;
        padding: 0.7em 1em;
      }
    }
  </style>
</head>
<body>
  <!-- Cosmic/party decorative background elements -->
  <div class="cosmic-decoration" style="top: 10%; left: 5%;">‚ô™</div>
  <div class="cosmic-decoration" style="top: 20%; right: 8%;">‚òÖ</div>
  <div class="cosmic-decoration" style="bottom: 15%; left: 10%;">‚ô´</div>
  <div class="cosmic-decoration" style="bottom: 25%; right: 15%;">‚ô¨</div>

  <div class="header-box">
    <h1>Karaoke ab Hof</h1>
    <img src="static/singing-chicken.png" class="singing-chicken">
  </div>
  <input type="text" id="search" placeholder="Lied suchen...">
  <div class="video-grid" id="videoList"></div>
  <div id="playerContainer">
    <video id="videoPlayer" autoplay disablepictureinpicture></video>
    <button id="closeBtn" onclick="closePlayer()">‚úï</button>
    <div class="video-overlay" id="videoOverlay">
      <button class="video-control-btn" id="playPauseBtn" onclick="togglePlayPause()">‚è∏ Pause</button>
      <button class="video-control-btn" onclick="restartVideo()">‚Üª Restart</button>
    </div>
  </div>
  <button id="statsButton">Stats</button>
  <div id="statsPage">
    <button id="closeStats">‚úï</button>
    <div style="padding: 20px; max-width: 1200px; margin: 0 auto;">
      <h2 style="color: #cd6391; text-align: center; margin-bottom: 30px; font-size: 2.5em;">üìä Karaoke Statistiken</h2>
      
      <!-- Statistics Summary Cards -->
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 40px;">
        <div class="stat-card">
          <h3>‚ô™ Total Songs</h3>
          <div class="stat-number" id="totalSongs">0</div>
        </div>
        <div class="stat-card">
          <h3>‚è± Total Play Time</h3>
          <div class="stat-number" id="totalPlayTime">0min</div>
        </div>
        <div class="stat-card">
          <h3>‚òÖ Most Played</h3>
          <div class="stat-number" id="mostPlayed">-</div>
        </div>
        <div class="stat-card">
          <h3>‚Üó Completion Rate</h3>
          <div class="stat-number" id="completionRate">0%</div>
        </div>
      </div>

      <!-- Large Most Played Chart -->
      <div class="chart-container" style="margin-bottom: 30px;">
        <h3>‚ô™ Most Played Songs (Top 15)</h3>
        <canvas id="mostPlayedChart" width="800" height="400"></canvas>
      </div>
      

      <!-- New Hourly Activity Chart -->
      <div class="chart-container" style="margin-bottom: 30px;">
        <h3>Activity Last 50 Hours (Completed vs Aborted)</h3>
        <canvas id="hourlyChart" width="800" height="400"></canvas>
      </div>

      <!-- Charts Container -->
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
        <div class="chart-container">
          <h3>ÔøΩ Completion Rate Distribution</h3>
          <canvas id="completionChart" width="400" height="250"></canvas>
        </div>
        <div class="chart-container">
          <h3>‚è∞ Play Time Distribution</h3>
          <canvas id="playTimeChart" width="400" height="300"></canvas>
        </div>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
        <div class="chart-container">
          <h3>üö´ Most Skipped Songs (Low Completion)</h3>
          <div id="skippedList" style="max-height: 300px; overflow-y: auto;"></div>
        </div>
        <div class="chart-container">
          <h3>‚ö° Instant Skips (<30 seconds)</h3>
          <div id="instantSkipsList" style="max-height: 300px; overflow-y: auto;"></div>
        </div>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
        <div class="chart-container">
          <h3>üíé Hidden Gems (Rare but Loved)</h3>
          <div id="hiddenGemsList" style="max-height: 300px; overflow-y: auto;"></div>
        </div>
        <div class="chart-container">
          <h3>üîÑ Retry Songs (Often Restarted)</h3>
          <div id="retryList" style="max-height: 300px; overflow-y: auto;"></div>
        </div>
      </div>

      <!-- Recent Activity -->
      <div class="chart-container">
        <h3>üïê Recent Activity</h3>
        <div id="recentActivity" style="max-height: 400px; overflow-y: auto;"></div>
      </div>

      <div style="text-align: center; margin-top: 30px;">
        <button onclick="exportStats()">üìÅ Export Data</button>
      </div>
    </div>
  </div>
  <script>
    let allVideos = [];
    let playedLog = JSON.parse(localStorage.getItem("playedLog") || "[]");
    let chartInstance = null;

    // Configuration for video display and search
    const CONFIG = {
      MAX_DISPLAY_COUNT: 50       // Maximum number of videos to display (both start page and search results)
    };

    async function loadVideos() {
      try {
        const res = await fetch("videos.json");
        const rawVideos = await res.json();
        
        // Transform to include computed file paths and display title
        allVideos = rawVideos.map(video => {
          // Handle both old format (title field) and new format (artist + title fields)
          let displayTitle, artist, title, searchText;
          
          if (video.artist && video.title) {
            // New format with separate artist and title
            artist = video.artist;
            title = video.title;
            displayTitle = `${artist} - ${title}`;
            searchText = `${artist} ${title}`.toLowerCase();
          } else if (video.artist || video.title) {
            // Partial new format - only one field available
            artist = video.artist || "";
            title = video.title || "";
            displayTitle = video.artist ? `${video.artist} - ${video.title || ""}` : video.title;
            searchText = `${artist} ${title}`.toLowerCase();
          } else if (video.title) {
            // Old format with combined title
            displayTitle = video.title;
            // Try to parse artist and title from combined title
            if (video.title.includes(' - ')) {
              const parts = video.title.split(' - ');
              artist = parts[0];
              title = parts.slice(1).join(' - ');
              searchText = `${artist} ${title}`.toLowerCase();
            } else {
              artist = "";
              title = video.title;
              searchText = video.title.toLowerCase();
            }
          } else {
            // Fallback - use filename without extension
            const filename = video.filename || video.file?.split('/').pop()?.replace(/\.[^/.]+$/, "") || "Unknown Song";
            displayTitle = filename;
            artist = "";
            title = filename;
            searchText = filename.toLowerCase();
          }
          
          return {
            ...video,
            file: video.file || `videos/${video.filename}.mp4`,
            cover: video.cover || `covers/${video.filename}.jpg`,
            displayTitle: displayTitle,
            artist: artist,
            title: title,
            searchText: searchText
          };
        });
        
        showRandomVideos();
      } catch (error) {
        console.error("Error loading videos:", error);
      }
    }

    function showRandomVideos() {
      const sample = shuffle([...allVideos]).slice(0, CONFIG.MAX_DISPLAY_COUNT);
      renderCards(sample);
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function renderCards(videos) {
      const container = document.getElementById("videoList");
      container.innerHTML = "";

      if (videos.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #ccc; padding: 2em;">Keine Videos gefunden</div>';
        return;
      }

      videos.forEach(v => {
        const div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `<img src="${v.cover}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDIwMCAxMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIyMDAiIGhlaWdodD0iMTIwIiBmaWxsPSIjNDQ0Ii8+Cjx0ZXh0IHg9IjEwMCIgeT0iNjAiIGZpbGw9IiNjY2MiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIwLjNlbSI+S2VpbiBCaWxkPC90ZXh0Pgo8L3N2Zz4='"><div class="title">${v.displayTitle}</div>`;
        div.onclick = () => playVideo(v);
        container.appendChild(div);
      });
    }



    function handleSearch(query) {
      if (!query || query.length === 0) {
        // Show random videos when search is empty
        showRandomVideos();
        return;
      }

      const searchTerms = query.toLowerCase().split(' ').filter(term => term.length > 0);

      // Filter videos based on search query (search in filename, artist, and title)
      const filteredVideos = allVideos.filter(v => {
        // Create an array of searchable fields
        const searchFields = [
          v.filename || "",
          v.artist || "",
          v.title || "",
          v.searchText || ""
        ];
        
        // Check if any search term matches any of the fields
        return searchTerms.some(term => 
          searchFields.some(field => 
            field.toLowerCase().includes(term)
          )
        );
      });

      if (filteredVideos.length === 0) {
        renderCards([]);
        return;
      }

      // Limit results to same number as start page
      const limitedResults = filteredVideos.slice(0, CONFIG.MAX_DISPLAY_COUNT);
      renderCards(limitedResults);
    }

    // Global session tracking variables
    let currentSessionStartTime = null;
    let currentVideoTitle = null;
    let isNewPlaySession = true;

    function playVideo(video) {
      const player = document.getElementById("videoPlayer");
      const container = document.getElementById("playerContainer");
      const btn = document.getElementById("closeBtn");

      player.src = video.file;
      container.style.display = "flex";
      btn.style.display = "block";

      // Hide cursor and button initially
      container.classList.remove("show-cursor");
      btn.classList.remove("visible");

      // Initialize session tracking
      currentSessionStartTime = Date.now();
      currentVideoTitle = video.displayTitle;
      isNewPlaySession = true;
      
      let playStartTime = 0;
      let totalDuration = 0;
      let ended = false;

      // Get video duration when metadata loads
      player.onloadedmetadata = () => {
        totalDuration = player.duration;
        playStartTime = player.currentTime;
        // Update button text when video starts playing (autoplay)
        const playPauseBtn = document.getElementById("playPauseBtn");
        playPauseBtn.textContent = "‚è∏ Pause";
      };

      player.onended = () => {
        ended = true;
        // Only log completion if this was a real play session
        if (isNewPlaySession) {
          logPlay(currentVideoTitle, currentSessionStartTime, totalDuration, totalDuration, true);
        }
        // Update button text when video ends
        const playPauseBtn = document.getElementById("playPauseBtn");
        playPauseBtn.textContent = "‚ñ∂ Play";
        closePlayer();
      };

      player.onpause = () => {
        // Don't log on pause - we only want to log actual plays, not pauses
        // Update button text when video is paused
        const playPauseBtn = document.getElementById("playPauseBtn");
        playPauseBtn.textContent = "‚ñ∂ Play";
      };

      player.onplay = () => {
        // Update button text when video starts playing
        const playPauseBtn = document.getElementById("playPauseBtn");
        playPauseBtn.textContent = "‚è∏ Pause";
        
        // If resuming from pause, don't count as new play
        if (player.currentTime > 1) { // If we're more than 1 second in, it's a resume
          isNewPlaySession = false;
        }
      };

      // Log initial play (only when video actually starts from beginning)
      logPlay(currentVideoTitle, currentSessionStartTime, 0, 0, false);
    }

    function closePlayer() {
      const player = document.getElementById("videoPlayer");
      const container = document.getElementById("playerContainer");
      const btn = document.getElementById("closeBtn");

      player.pause();
      player.src = "";
      container.style.display = "none";

      // Reset cursor and button state
      container.classList.remove("show-cursor");
      btn.classList.remove("visible");
    }

    function logPlay(title, timestamp, playedSeconds, totalDuration, completed) {
      playedLog.push({ 
        title, 
        timestamp, 
        playedSeconds: Math.round(playedSeconds), 
        totalDuration: Math.round(totalDuration), 
        completed,
        playPercentage: totalDuration > 0 ? Math.round((playedSeconds / totalDuration) * 100) : 0
      });
      localStorage.setItem("playedLog", JSON.stringify(playedLog));
    }

    // Enhanced search with intelligent filtering
    document.getElementById("search").addEventListener("input", e => {
      const query = e.target.value.trim();
      handleSearch(query);
    });

    // Mouse movement handling for video player
    document.addEventListener("mousemove", () => {
      const container = document.getElementById("playerContainer");
      const btn = document.getElementById("closeBtn");
      const overlay = document.getElementById("videoOverlay");
      
      if (container.style.display === "flex") {
        // Show cursor, button, and controls on mouse movement
        container.classList.add("show-cursor");
        btn.classList.add("visible");
        overlay.classList.add("visible");
        
        // Hide again after 3 seconds of no movement
        clearTimeout(window.hideTimer);
        window.hideTimer = setTimeout(() => {
          container.classList.remove("show-cursor");
          btn.classList.remove("visible");
          overlay.classList.remove("visible");
        }, 3000);
      }
    });

    // Custom video control functions
    function togglePlayPause() {
      const player = document.getElementById("videoPlayer");
      const playPauseBtn = document.getElementById("playPauseBtn");
      if (player.paused) {
        player.play();
        playPauseBtn.textContent = "‚è∏ Pause";
      } else {
        player.pause();
        playPauseBtn.textContent = "‚ñ∂ Play";
      }
    }

    function toggleMute() {
      const player = document.getElementById("videoPlayer");
      player.muted = !player.muted;
    }

    function adjustVolume(change) {
      const player = document.getElementById("videoPlayer");
      const newVolume = Math.max(0, Math.min(1, player.volume + change));
      player.volume = newVolume;
    }

    function restartVideo() {
      const player = document.getElementById("videoPlayer");
      const playPauseBtn = document.getElementById("playPauseBtn");
      
      // Reset to beginning and mark as new play session
      player.currentTime = 0;
      player.play();
      playPauseBtn.textContent = "‚è∏ Pause";
      
      // This counts as a new play session
      currentSessionStartTime = Date.now();
      isNewPlaySession = true;
      
      // Log the restart as a new play
      if (currentVideoTitle) {
        logPlay(currentVideoTitle, currentSessionStartTime, 0, 0, false);
      }
    }

    // Keyboard shortcuts
    document.addEventListener("keydown", e => {
      const playerContainer = document.getElementById("playerContainer");
      const statsPage = document.getElementById("statsPage");
      const searchField = document.getElementById("search");

      if (e.key === "Escape") {
        // If video is playing, close it
        if (playerContainer.style.display === "flex") {
          closePlayer();
        }
        // If stats page is open, close it
        else if (statsPage.style.display === "block") {
          statsPage.style.display = "none";
        }
        // If neither video nor stats are open, clear search field
        else {
          searchField.value = "";
          showRandomVideos();
        }
      }
      // Clear search with Ctrl+K or Cmd+K
      if ((e.ctrlKey || e.metaKey) && e.key === "k") {
        e.preventDefault();
        searchField.value = "";
        showRandomVideos();
        searchField.focus();
      }
    });

    // Statistics functionality
    document.getElementById("statsButton").onclick = () => {
      document.getElementById("statsPage").style.display = "block";
      renderChart();
    };

    document.getElementById("closeStats").onclick = () => {
      document.getElementById("statsPage").style.display = "none";
    };

    function exportStats() {
      const logs = JSON.parse(localStorage.getItem("playedLog") || "[]");
      const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "karaoke_stats.json";
      a.click();
      URL.revokeObjectURL(url);
    }

    function renderChart() {
      const logs = JSON.parse(localStorage.getItem("playedLog") || "[]");
      
      if (logs.length === 0) {
        document.getElementById('totalSongs').textContent = '0';
        document.getElementById('totalPlayTime').textContent = '0min';
        document.getElementById('mostPlayed').textContent = '-';
        document.getElementById('completionRate').textContent = '0%';
        return;
      }

      // Calculate statistics
      const stats = calculateStatistics(logs);
      
      // Update summary cards
      updateSummaryCards(stats);
      
      // Render charts
      renderMostPlayedChart(stats.mostPlayedSongs);
      renderPlayTimeChart(stats.playTimeDistribution);
      renderHourlyChart(stats.hourlyActivity);
      renderSkippedList(stats.skippedSongs);
      renderInstantSkipsList(stats.instantSkips);
      renderHiddenGemsList(stats.hiddenGems);
      renderRetryList(stats.retrySongs);
      renderCompletionChart(stats.completionDistribution);
      renderRecentActivity(logs.slice(-10).reverse());
    }

    function calculateStatistics(logs) {
      const songStats = {};
      const dailyActivity = {};
      const hourlyActivity = {
        completed: Array(50).fill(0),
        aborted: Array(50).fill(0),
        labels: []
      };
      let totalPlayTime = 0;
      let completedSongs = 0;

      logs.forEach(log => {
        if (!songStats[log.title]) {
          songStats[log.title] = {
            playCount: 0,
            totalPlayTime: 0,
            totalDuration: 0,
            completions: 0,
            avgCompletion: 0,
            instantSkips: 0, // <30 seconds
            restarts: 0 // Multiple plays in short time
          };
        }

        const song = songStats[log.title];
        song.playCount++;
        song.totalPlayTime += log.playedSeconds || 0;
        if (log.totalDuration > 0) song.totalDuration = log.totalDuration;
        if (log.completed) song.completions++;
        
        // Count instant skips (<30 seconds)
        if (log.playedSeconds < 30) song.instantSkips++;

        totalPlayTime += log.playedSeconds || 0;
        if (log.completed) completedSongs++;

        // Daily activity
        const date = new Date(log.timestamp).toDateString();
        dailyActivity[date] = (dailyActivity[date] || 0) + 1;

      });

      // Generate labels for last 50 hours
      const now = new Date();
      for (let i = 49; i >= 0; i--) {
        const hourTime = new Date(now.getTime() - i * 60 * 60 * 1000);
        const label = `${hourTime.getDate().toString().padStart(2, '0')}.${(hourTime.getMonth() + 1).toString().padStart(2, '0')} ${hourTime.getHours().toString().padStart(2, '0')}:00`;
        hourlyActivity.labels.push(label);
      }

      // Count activities in last 50 hours
      logs.forEach(log => {
        const logTime = new Date(log.timestamp);
        const hoursAgo = Math.floor((now - logTime) / (1000 * 60 * 60));
        
        if (hoursAgo >= 0 && hoursAgo < 50) {
          const index = 49 - hoursAgo; // Reverse index (0 = 49 hours ago, 49 = current hour)
          if (log.completed) {
            hourlyActivity.completed[index]++;
          } else {
            hourlyActivity.aborted[index]++;
          }
        }
      });

      // Calculate average completion rates and detect restarts
      Object.keys(songStats).forEach(title => {
        const song = songStats[title];
        song.avgCompletion = song.playCount > 0 ? (song.completions / song.playCount) * 100 : 0;
        
        // Simple restart detection: high play count vs completion rate
        if (song.playCount > 3 && song.avgCompletion < 50) {
          song.restarts = song.playCount - song.completions;
        }
      });

      // Get most played songs (top 15)
      const mostPlayedSongs = Object.entries(songStats)
        .sort(([,a], [,b]) => b.playCount - a.playCount)
        .slice(0, 15);

      // Get most skipped songs (played multiple times but low completion rate)
      const skippedSongs = Object.entries(songStats)
        .filter(([,song]) => song.playCount >= 2 && song.avgCompletion < 40)
        .sort(([,a], [,b]) => a.avgCompletion - b.avgCompletion)
        .slice(0, 10);

      // Get instant skip songs (most songs stopped within 30 seconds)
      const instantSkips = Object.entries(songStats)
        .filter(([,song]) => song.instantSkips >= 2)
        .sort(([,a], [,b]) => b.instantSkips - a.instantSkips)
        .slice(0, 10);

      // Get hidden gems (rarely played but high completion when they are)
      const hiddenGems = Object.entries(songStats)
        .filter(([,song]) => song.playCount <= 3 && song.avgCompletion > 70 && song.playCount > 0)
        .sort(([,a], [,b]) => b.avgCompletion - a.avgCompletion)
        .slice(0, 10);

      // Get retry songs (often restarted)
      const retrySongs = Object.entries(songStats)
        .filter(([,song]) => song.restarts > 0)
        .sort(([,a], [,b]) => b.restarts - a.restarts)
        .slice(0, 10);

      // Play time distribution
      const playTimeRanges = {
        '0-25%': 0,
        '26-50%': 0,
        '51-75%': 0,
        '76-100%': 0
      };

      logs.forEach(log => {
        if (log.playPercentage <= 25) playTimeRanges['0-25%']++;
        else if (log.playPercentage <= 50) playTimeRanges['26-50%']++;
        else if (log.playPercentage <= 75) playTimeRanges['51-75%']++;
        else playTimeRanges['76-100%']++;
      });

      // Completion rate distribution for all songs
      const completionDistribution = {
        'Very Low (0-20%)': 0,
        'Low (21-40%)': 0,
        'Medium (41-60%)': 0,
        'High (61-80%)': 0,
        'Very High (81-100%)': 0
      };

      Object.values(songStats).forEach(song => {
        if (song.avgCompletion <= 20) completionDistribution['Very Low (0-20%)']++;
        else if (song.avgCompletion <= 40) completionDistribution['Low (21-40%)']++;
        else if (song.avgCompletion <= 60) completionDistribution['Medium (41-60%)']++;
        else if (song.avgCompletion <= 80) completionDistribution['High (61-80%)']++;
        else completionDistribution['Very High (81-100%)']++;
      });

      return {
        totalSongs: Object.keys(songStats).length,
        totalPlayTime: Math.round(totalPlayTime / 60),
        mostPlayedSong: mostPlayedSongs[0] ? mostPlayedSongs[0][0] : '-',
        completionRate: Math.round((completedSongs / logs.length) * 100),
        mostPlayedSongs,
        skippedSongs,
        instantSkips,
        hiddenGems,
        retrySongs,
        playTimeDistribution: playTimeRanges,
        completionDistribution,
        dailyActivity,
        hourlyActivity
      };
    }

    function updateSummaryCards(stats) {
      document.getElementById('totalSongs').textContent = stats.totalSongs;
      document.getElementById('totalPlayTime').textContent = `${stats.totalPlayTime}min`;
      document.getElementById('mostPlayed').textContent = stats.mostPlayedSong;
      document.getElementById('completionRate').textContent = `${stats.completionRate}%`;
    }

    function renderMostPlayedChart(mostPlayedSongs) {
      const ctx = document.getElementById('mostPlayedChart').getContext('2d');
      
      if (window.mostPlayedChartInstance) window.mostPlayedChartInstance.destroy();
      
      if (mostPlayedSongs.length === 0) {
        ctx.fillStyle = '#fff';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data available', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return;
      }

      window.mostPlayedChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: mostPlayedSongs.map(([title]) => title.length > 25 ? title.substring(0, 25) + '...' : title),
          datasets: [{
            label: 'Play Count',
            data: mostPlayedSongs.map(([, song]) => song.playCount),
            backgroundColor: 'rgba(205, 99, 145, 0.8)',
            borderColor: '#cd6391',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false }
          },
          scales: {
            x: { 
              ticks: { 
                color: '#fff', 
                maxRotation: 45,
                font: { size: 10 }
              },
              grid: { color: 'rgba(255, 255, 255, 0.1)' }
            },
            y: { 
              ticks: { color: '#fff' },
              grid: { color: 'rgba(255, 255, 255, 0.1)' },
              title: {
                display: true,
                text: 'Play Count',
                color: '#fff'
              }
            }
          }
        }
      });
    }

    function renderPlayTimeChart(playTimeDistribution) {
      const ctx = document.getElementById('playTimeChart').getContext('2d');
      
      if (window.playTimeChartInstance) window.playTimeChartInstance.destroy();

      window.playTimeChartInstance = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: Object.keys(playTimeDistribution),
          datasets: [{
            data: Object.values(playTimeDistribution),
            backgroundColor: [
              'rgba(244, 67, 54, 0.8)',
              'rgba(255, 152, 0, 0.8)',
              'rgba(255, 235, 59, 0.8)',
              'rgba(76, 175, 80, 0.8)'
            ],
            borderColor: '#fff',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { 
              position: 'bottom',
              labels: { color: '#fff' }
            }
          }
        }
      });
    }

    function renderHourlyChart(hourlyActivity) {
      const ctx = document.getElementById('hourlyChart').getContext('2d');
      
      if (window.hourlyChartInstance) window.hourlyChartInstance.destroy();

      window.hourlyChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: hourlyActivity.labels,
          datasets: [
            {
              label: 'Completed Songs',
              data: hourlyActivity.completed,
              backgroundColor: 'rgba(75, 192, 75, 0.8)',
              borderColor: '#4bc04b',
              borderWidth: 1
            },
            {
              label: 'Aborted Songs',
              data: hourlyActivity.aborted,
              backgroundColor: 'rgba(255, 99, 99, 0.8)',
              borderColor: '#ff6363',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { 
              display: true,
              labels: { color: '#fff' }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                title: function(tooltipItems) {
                  return tooltipItems[0].label;
                }
              }
            }
          },
          scales: {
            x: { 
              stacked: true,
              ticks: { 
                color: '#fff',
                maxRotation: 45,
                callback: function(value, index) {
                  // Show every 6th label to avoid crowding (50 hours / 8 ‚âà 6)
                  return index % 6 === 0 ? this.getLabelForValue(value) : '';
                }
              },
              grid: { color: 'rgba(255, 255, 255, 0.1)' }
            },
            y: { 
              stacked: true,
              ticks: { color: '#fff' },
              grid: { color: 'rgba(255, 255, 255, 0.1)' },
              title: {
                display: true,
                text: 'Number of Songs',
                color: '#fff'
              }
            }
          }
        }
      });
    }

    function renderSkippedList(skippedSongs) {
      const container = document.getElementById('skippedList');
      
      if (skippedSongs.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #ccc; padding: 2em;">No skipped songs yet.<br>Songs appear here when played multiple times but rarely completed.</div>';
        return;
      }

      container.innerHTML = skippedSongs.map(([title, song]) => `
        <div class="favorite-item">
          <div class="song-title">${title}</div>
          <div class="completion" style="color: #ff6b6b;">${Math.round(song.avgCompletion)}% completion ‚Ä¢ ${song.playCount} attempts</div>
        </div>
      `).join('');
    }

    function renderInstantSkipsList(instantSkips) {
      const container = document.getElementById('instantSkipsList');
      
      if (instantSkips.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #ccc; padding: 2em;">No instant skips detected.<br>Songs appear here when stopped within 30 seconds multiple times.</div>';
        return;
      }

      container.innerHTML = instantSkips.map(([title, song]) => `
        <div class="favorite-item">
          <div class="song-title">${title}</div>
          <div class="completion" style="color: #ff9800;">${song.instantSkips} instant skips ‚Ä¢ ${song.playCount} total plays</div>
        </div>
      `).join('');
    }

    function renderHiddenGemsList(hiddenGems) {
      const container = document.getElementById('hiddenGemsList');
      
      if (hiddenGems.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #ccc; padding: 2em;">No hidden gems found.<br>Songs appear here when rarely played but highly completed.</div>';
        return;
      }

      container.innerHTML = hiddenGems.map(([title, song]) => `
        <div class="favorite-item">
          <div class="song-title">${title}</div>
          <div class="completion" style="color: #4caf50;">${Math.round(song.avgCompletion)}% completion ‚Ä¢ Only ${song.playCount} plays</div>
        </div>
      `).join('');
    }

    function renderRetryList(retrySongs) {
      const container = document.getElementById('retryList');
      
      if (retrySongs.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #ccc; padding: 2em;">No retry patterns detected.<br>Songs appear here when frequently restarted.</div>';
        return;
      }

      container.innerHTML = retrySongs.map(([title, song]) => `
        <div class="favorite-item">
          <div class="song-title">${title}</div>
          <div class="completion" style="color: #ff9800;">${song.restarts} restarts ‚Ä¢ ${song.playCount} total plays</div>
        </div>
      `).join('');
    }

    function renderCompletionChart(completionDistribution) {
      const ctx = document.getElementById('completionChart').getContext('2d');
      
      if (window.completionChartInstance) window.completionChartInstance.destroy();

      window.completionChartInstance = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: Object.keys(completionDistribution),
          datasets: [{
            data: Object.values(completionDistribution),
            backgroundColor: [
              'rgba(244, 67, 54, 0.8)',
              'rgba(255, 152, 0, 0.8)',
              'rgba(255, 235, 59, 0.8)',
              'rgba(139, 195, 74, 0.8)',
              'rgba(76, 175, 80, 0.8)'
            ],
            borderColor: '#fff',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { 
              position: 'bottom',
              labels: { 
                color: '#fff',
                font: { size: 10 }
              }
            }
          }
        }
      });
    }

    function renderRecentActivity(recentLogs) {
      const container = document.getElementById('recentActivity');
      
      if (recentLogs.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #ccc; padding: 1em;">No recent activity</div>';
        return;
      }

      container.innerHTML = recentLogs.map(log => `
        <div class="activity-item">
          <div class="song-title">${log.title}</div>
          <div class="time">${new Date(log.timestamp).toLocaleString('de-DE')} ‚Ä¢ ${log.playPercentage}%</div>
        </div>
      `).join('');
    }

    // Initialize the application
    loadVideos();
  </script>
</body>
</html>
